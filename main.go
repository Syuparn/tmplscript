package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"golang.org/x/xerrors"
)

var (
	fileName     = flag.String("f", "", "use template file")
	runsREPL     = flag.Bool("i", false, "run interactive REPL instead")
	showsVersion = flag.Bool("v", false, "show version")
	leftDelim    = flag.String("ldelim", "{{", "specify left deliminater")
	rightDelim   = flag.String("rdelim", "}}", "specify right deliminater")
)

func main() {
	err := run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "%+v\n", err)
		os.Exit(1)
	}
	os.Exit(0)
}

func run() error {
	flag.Parse()

	if *showsVersion {
		fmt.Println(versionStr())
		return nil
	}

	tmpl := newTemplate(*leftDelim, *rightDelim)

	if *runsREPL {
		return runREPLMode(tmpl)
	}

	if *fileName != "" {
		fp, err := os.Open(*fileName)
		if err != nil {
			return xerrors.Errorf("failed to open %s: %w", *fileName, err)
		}

		b, err := ioutil.ReadAll(fp)
		if err != nil {
			return xerrors.Errorf("failed to read %s: %w", *fileName, err)
		}

		return runPipeMode(tmpl, string(b))
	}

	if flag.Arg(0) == "" {
		return xerrors.Errorf("template must be passed to argument")
	}

	return runPipeMode(tmpl, flag.Arg(0))
}

func runPipeMode(tmplGen *template.Template, tmplStr string) error {
	tmpl, err := tmplGen.Parse(tmplStr)
	if err != nil {
		return xerrors.Errorf("template error: %w", err)
	}

	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		line := scanner.Text()

		err = tmpl.Execute(os.Stdout, line)
		if err != nil {
			return xerrors.Errorf("runtime error: %w", err)
		}
	}

	return nil
}

func runREPLMode(tmplGen *template.Template) error {
	scanner := bufio.NewScanner(os.Stdin)
	tmplStr := ""
	lineNum := 1

	for {
		// show prompt
		fmt.Printf("tmpl:%d> ", lineNum)

		ok := scanner.Scan()
		if !ok {
			// end of repl
			// HACK: prepend \n to break line even if repl is stopped by SIGINT
			fmt.Println("\nBye.")
			return nil
		}

		line := scanner.Text() + "\n"

		// NOTE: whole history is necessary to refer previous variable statement
		// HACK: insert "\034"(, which is not printable) to detect
		//       output generated by the latest input line
		tmpl, err := tmplGen.Parse(tmplStr + "\034" + line)
		if err != nil {
			fmt.Fprintf(os.Stderr, "template error:\n%v\n", err)
			continue
		}

		out := new(bytes.Buffer)
		err = tmpl.Execute(out, nil)
		if err != nil {
			fmt.Fprintf(os.Stderr, "runtime error:\n%v\n", err)
			continue
		}
		// print only added output, which corresponds to the latest input
		splitted := strings.Split(out.String(), "\034")
		if len(splitted) != 2 {
			fmt.Fprintf(os.Stderr,
				"runtime error:\nthere must be 1 internal delimiter \\034 (found %d)\n", len(splitted)-1)
			continue
		}

		diffStr := splitted[1]
		fmt.Println(diffStr)

		tmplStr = tmplStr + line
		lineNum++
	}
}

func newTemplate(leftDelim, rightDelim string) *template.Template {
	return template.New("tmpl").Delims(leftDelim, rightDelim).Funcs(funcMap())
}
